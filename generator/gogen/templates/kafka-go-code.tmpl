// Package {{.packageName}} provides primitives to interact with the asyncAPI.
//
// Code generated by github.com/c0olix/asyncApiCodeGen DO NOT EDIT.
package {{.packageName}}
{{ $messages := getMessages .}} {{$objects := getObjects $messages}} {{$items := getItemObjects $messages}}
import (
	"context"
	"encoding/json"
	"github.com/c0olix/goChan"
	"github.com/c0olix/goChan/kafka"
	"github.com/go-playground/validator/v10"
{{if hasProducer .}}
	"github.com/pkg/errors"
	kafkaGo "github.com/segmentio/kafka-go"
{{- end}}
	"reflect"
{{- range $imp := getImports .}}
	"{{$imp}}"
{{- end}}
)

const (
{{- range $channelName, $channel := .channels }}
	{{ lower $channelName | camel}}TopicName = "{{$channelName}}"
{{- end}}
)

var validate *validator.Validate = validator.New()

func UnmarshalEvent(proto interface{}, messageArray []byte) (interface{}, error) {
	eventType := reflect.TypeOf(proto)
	value := reflect.New(eventType).Interface()
	err := json.Unmarshal(messageArray, value)
	return value, err
}

{{ range $message := $messages }}
// {{$message.name}} {{$message.description}}
type {{$message.name}} struct {
  {{- range $propertyName, $property := $message.payload.properties}} {{$required := checkRequired $propertyName $message.payload.required}}
  {{camel $propertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $property -}} `json:"{{$propertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $property $required }}`
  {{- end}}
}

// Validate validates the {{$message.name}}) struct for its requirements
func (thiz {{$message.name}}) Validate() error{
	return validate.Struct(thiz)
}

// New{{$message.name}} creates a new struct of the {{$message.name}} type and validates its content
func New{{$message.name}}({{range $propertyName, $property := $message.payload.properties}}{{$required := checkRequired $propertyName $message.payload.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$message.name}},error) {
	{{lowerCamel $message.name}} := {{$message.name}}{
		{{- range $propertyName, $property := $message.payload.properties}}
		{{camel $propertyName}}: {{$propertyName}},
    {{- end}}
	}
	err := {{lowerCamel $message.name}}.Validate()
	if err != nil {
	  return nil, err
	}
	return &{{lowerCamel $message.name}}, nil
}
{{ end}}

{{ range $object := $objects }}
// {{$object.title}} Nested object for {{$object.parent}} type
type {{$object.title}} struct {
  {{- range $objPropertyName, $objProperty := $object.properties}} {{$required := checkRequired $objPropertyName $object.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $objProperty $required }}`
  {{- end}}
}

// Validate validates the {{$object.title}} struct for its requirements
func (thiz {{$object.title}}) Validate() error{
  return validate.Struct(thiz)
}

// New{{$object.title}} creates a new struct of the {{$object.title}} type and validates its content
func New{{$object.title}}({{range $propertyName, $property := $object.properties}}{{$required := checkRequired $propertyName $object.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$object.title}},error) {
	{{lowerCamel $object.title}} := {{$object.title}}{
{{- range $propertyName, $property := $object.properties}}
    	{{camel $propertyName}}: {{$propertyName}},
{{- end}}
	}
	err := {{lowerCamel $object.title}}.Validate()
	if err != nil {
		return nil, err
	}
	return &{{lowerCamel $object.title}}, nil
}
{{- end}}
{{ range $item := $items }}

// {{$item.items.title}} Nested object for {{$item.parent}} type
type {{$item.items.title}} struct {
  {{- range $objPropertyName, $objProperty := $item.items.properties}} {{$required := checkRequired $objPropertyName $item.items.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $objProperty $required }}`
  {{- end}}
}

// Validate validates the {{$item.items.title}} struct for its requirements
func (thiz {{$item.items.title}}) Validate() error{
	return validate.Struct(thiz)
}

// New{{$item.items.title}} creates a new struct of the {{$item.items.title}} type and validates its content
func New{{$item.items.title}}({{range $propertyName, $property := $item.items.properties}}{{$required := checkRequired $propertyName $item.items.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$item.items.title}},error) {
	{{lowerCamel $item.items.title}} := {{$item.items.title}}{
{{- range $propertyName, $property := $item.items.properties}}
    	{{camel $propertyName}}: {{$propertyName}},
{{- end}}
	}
	err := {{lowerCamel $item.items.title}}.Validate()
	if err != nil {
		return nil, err
	}
	return &{{lowerCamel $item.items.title}}, nil
}
{{- end}}


// ConsumerInterface Interface for all events to be consumed by application
type ConsumerInterface interface {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{camel $channel.publish.operationId}}(handler goChan.Handler)
    {{- end}}
{{- end}}
}

// ProducerInterface Interface for all events to be produced by application
type ProducerInterface interface {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{camel $channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}) error
    {{- end}}
{{- end}}
}

// DefaultConsumer implements ConsumerInterface and consumes events with go kafka mosaic style flavor
type DefaultConsumer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic goChan.ChannelInterface
    {{- end}}
{{- end}}
}

// DefaultProducer implements ProducerInterface and produces events with go kafka mosaic style flavor
type DefaultProducer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic goChan.ChannelInterface
    {{- end}}
{{- end}}
}

// NewDefaultConsumer wires all needed dependencies to create a DefaultConsumer
func NewDefaultConsumer(manager goChan.ManagerInterface, errorCallback func(ctx context.Context, err error), config kafka.ChannelConfig, mw ...goChan.Middleware) (*DefaultConsumer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateChannel({{ lower $channelName | camel}}TopicName, errorCallback, config)
	if err != nil {
		return nil, err
	}
  {{ lower $channelName | camel}}Topic.SetReaderMiddleWares(mw...)
    {{- end}}
{{- end}}
	return &DefaultConsumer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

// NewDefaultProducer wires all needed dependencies to create a DefaultProducer
func NewDefaultProducer(manager goChan.ManagerInterface, errorCallback func(ctx context.Context, err error), config kafka.ChannelConfig, mw ...goChan.Middleware) (*DefaultProducer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateChannel({{ lower $channelName | camel}}TopicName, errorCallback, config)
	if err != nil {
		return nil, err
	}
  {{ lower $channelName | camel}}Topic.SetWriterMiddleWares(mw...)
    {{- end}}
{{- end}}
	return &DefaultProducer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
//{{camel $channel.publish.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to consume the {{$channel.publish.message.name}} Event.
func (d DefaultConsumer)  {{camel $channel.publish.operationId}} (handler goChan.Handler) {
	d.{{ lower $channelName | camel}}Topic.Consume(handler)
}
    {{- end}}
{{ end}}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
//{{camel $channel.subscribe.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to produce the {{$channel.subscribe.message.name}} Event.
func (d DefaultProducer) {{camel $channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}) error {
	eventData, err := json.Marshal(event)
	if err != nil {
		return errors.Wrap(err, "unable to marshal eventdata")
	}
	msg := kafkaGo.Message{
		Value:         eventData,
	}
	err = d.{{ lower $channelName | camel}}Topic.Produce(ctx, msg)
	if err != nil {
		return err
	}
	return nil
}
    {{- end}}
{{- end}}