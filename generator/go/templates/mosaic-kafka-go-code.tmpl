// Package events provides primitives to interact with the asyncAPI.
//
// Code generated by github.com/c0olix/asyncApiCodeGen DO NOT EDIT.
package events
{{ $messages := getMessages .}} {{$objects := getObjects $messages}} {{$items := getItemObjects $messages}}
import (
	"context"
	"git.hochbahn.cloud/mosaic/libs/go-microservice-starter-commons.git/messaging"
{{- range $imp := getImports .}}
	"{{$imp}}"
{{- end}}
)

const (
{{- range $channelName, $channel := .channels }}
	{{ lower $channelName | camel}}TopicName = "{{$channelName}}"
{{- end}}
)

// KafkaTopicConfig Holds configuration needed fo create a kafka topic
type KafkaTopicConfig struct {
	TopicGroup string
	NumPartitions int
	ReplicationFactor int
}

{{ range $message := $messages }}
// {{$message.name}} {{$message.description}}
type {{$message.name}} struct {
  {{- range $propertyName, $property := $message.payload.properties}} {{$required := checkRequired $propertyName $message.payload.required}}
  {{camel $propertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $property -}} `json:"{{$propertyName}}{{if not $required -}},omitempty{{- end}}"`
  {{- end}}
}
{{ end}}

{{ range $object := $objects }}
// {{$object.title}} Nested object for {{$object.parent}} type
type {{$object.title}} struct {
  {{- range $objPropertyName, $objProperty := $object.properties}} {{$required := checkRequired $objPropertyName $object.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"`
  {{- end}}
}
{{- end}}
{{ range $item := $items }}

// {{$item.items.title}} Nested object for {{$item.parent}} type
type {{$item.items.title}} struct {
  {{- range $objPropertyName, $objProperty := $item.items.properties}} {{$required := checkRequired $objPropertyName $item.items.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"`
  {{- end}}
}
{{- end}}


// ConsumerInterface Interface for all events to be consumed by application
type ConsumerInterface interface {
{{ range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{$channel.publish.operationId}}(callback messaging.CallbackFunction, errorCallback messaging.ErrorCallbackFunction)
    {{- end}}
{{- end}}
}

// ProducerInterface Interface for all events to be produced by application
type ProducerInterface interface {
{{ range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{$channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}, header ...messaging.KafkaHeader) error
    {{- end}}
{{- end}}
}

// DefaultConsumer implements ConsumerInterface and consumes events with go kafka mosaic style flavor
type DefaultConsumer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic messaging.KafkaTopic
    {{- end}}
{{- end}}
}

// DefaultProducer implements ProducerInterface and produces events with go kafka mosaic style flavor
type DefaultProducer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic messaging.KafkaTopic
    {{- end}}
{{- end}}
}

// NewDefaultConsumer wires all needed dependencies to create a DefaultConsumer
func NewDefaultConsumer(manager messaging.KafkaManager, config KafkaTopicConfig) (*DefaultConsumer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateTopic({{ lower $channelName | camel}}TopicName, config.TopicGroup, config.NumPartitions, config.ReplicationFactor)
	if err != nil {
		return nil, err
	}
    {{- end}}
{{- end}}
	return &DefaultConsumer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

// NewDefaultProducer wires all needed dependencies to create a DefaultProducer
func NewDefaultProducer(manager messaging.KafkaManager, config KafkaTopicConfig) (*DefaultProducer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateTopic({{ lower $channelName | camel}}TopicName, config.TopicGroup, config.NumPartitions, config.ReplicationFactor)
	if err != nil {
		return nil, err
	}
    {{- end}}
{{- end}}
	return &DefaultProducer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
//{{$channel.publish.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to consume the {{$channel.publish.message.name}} Event.
func (d DefaultConsumer)  {{$channel.publish.operationId}} (callback messaging.CallbackFunction, errorCallback messaging.ErrorCallbackFunction) {
	d.{{ lower $channelName | camel}}Topic.Consume({{$channel.publish.message.name}}{}, callback, errorCallback)
}
    {{- end}}
{{ end}}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
//{{$channel.subscribe.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to produce the {{$channel.subscribe.message.name}} Event.
func (d DefaultProducer) {{$channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}, header ...messaging.KafkaHeader) error {
	err := d.{{ lower $channelName | camel}}Topic.Produce(ctx, event, header...)
	if err != nil {
		return err
	}
	return nil
}
    {{- end}}
{{ end}}