// Package events provides primitives to interact with the asyncAPI.
//
// Code generated by github.com/c0olix/asyncApiCodeGen DO NOT EDIT.
package events
{{ $messages := getMessages .}} {{$objects := getObjects $messages}} {{$items := getItemObjects $messages}}
import (
	"context"
	"git.hochbahn.cloud/mosaic/libs/go-microservice-starter-commons.git/messaging"
	"github.com/go-playground/validator/v10"
{{- range $imp := getImports .}}
	"{{$imp}}"
{{- end}}
)

const (
{{- range $channelName, $channel := .channels }}
	{{ lower $channelName | camel}}TopicName = "{{$channelName}}"
{{- end}}
)

var validate *validator.Validate = validator.New()

// KafkaTopicConfig Holds configuration needed fo create a kafka topic
type KafkaTopicConfig struct {
	TopicGroup string
	NumPartitions int
	ReplicationFactor int
}

{{ range $message := $messages }}
// {{$message.name}} {{$message.description}}
type {{$message.name}} struct {
  {{- range $propertyName, $property := $message.payload.properties}} {{$required := checkRequired $propertyName $message.payload.required}}
  {{camel $propertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $property -}} `json:"{{$propertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $property $required }}`
  {{- end}}
}

// Validate validates the {{$message.name}}) struct for its requirements
func (thiz {{$message.name}}) Validate() error{
	return validate.Struct(thiz)
}

// New{{$message.name}} creates a new struct of the {{$message.name}} type and validates its content
func New{{$message.name}}({{range $propertyName, $property := $message.payload.properties}}{{$required := checkRequired $propertyName $message.payload.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$message.name}},error) {
	{{lowerCamel $message.name}} := {{$message.name}}{
		{{- range $propertyName, $property := $message.payload.properties}}
		{{camel $propertyName}}: {{$propertyName}},
    {{- end}}
	}
	err := {{lowerCamel $message.name}}.Validate()
	if err != nil {
	  return nil, err
	}
	return &{{lowerCamel $message.name}}, nil
}
{{ end}}

{{ range $object := $objects }}
// {{$object.title}} Nested object for {{$object.parent}} type
type {{$object.title}} struct {
  {{- range $objPropertyName, $objProperty := $object.properties}} {{$required := checkRequired $objPropertyName $object.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $objProperty $required }}`
  {{- end}}
}

// Validate validates the {{$object.title}} struct for its requirements
func (thiz {{$object.title}}) Validate() error{
  return validate.Struct(thiz)
}

// New{{$object.title}} creates a new struct of the {{$object.title}} type and validates its content
func New{{$object.title}}({{range $propertyName, $property := $object.properties}}{{$required := checkRequired $propertyName $object.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$object.title}},error) {
	{{lowerCamel $object.title}} := {{$object.title}}{
{{- range $propertyName, $property := $object.properties}}
    	{{camel $propertyName}}: {{$propertyName}},
{{- end}}
	}
	err := {{lowerCamel $object.title}}.Validate()
	if err != nil {
		return nil, err
	}
	return &{{lowerCamel $object.title}}, nil
}
{{- end}}
{{ range $item := $items }}

// {{$item.items.title}} Nested object for {{$item.parent}} type
type {{$item.items.title}} struct {
  {{- range $objPropertyName, $objProperty := $item.items.properties}} {{$required := checkRequired $objPropertyName $item.items.required}}
  {{camel $objPropertyName}} {{if not $required -}}*{{- end}}{{ convertToGoType $objProperty -}} `json:"{{$objPropertyName}}{{if not $required -}},omitempty{{- end}}"{{validations $objProperty $required }}`
  {{- end}}
}

// Validate validates the {{$item.items.title}} struct for its requirements
func (thiz {{$item.items.title}}) Validate() error{
	return validate.Struct(thiz)
}

// New{{$item.items.title}} creates a new struct of the {{$item.items.title}} type and validates its content
func New{{$item.items.title}}({{range $propertyName, $property := $item.items.properties}}{{$required := checkRequired $propertyName $item.items.required}}{{$propertyName}} {{if not $required}}*{{end}}{{ convertToGoType $property}},{{end}}) (*{{$item.items.title}},error) {
	{{lowerCamel $item.items.title}} := {{$item.items.title}}{
{{- range $propertyName, $property := $item.items.properties}}
    	{{camel $propertyName}}: {{$propertyName}},
{{- end}}
	}
	err := {{lowerCamel $item.items.title}}.Validate()
	if err != nil {
		return nil, err
	}
	return &{{lowerCamel $item.items.title}}, nil
}
{{- end}}


// ConsumerInterface Interface for all events to be consumed by application
type ConsumerInterface interface {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{camel $channel.publish.operationId}}(callback messaging.CallbackFunction, errorCallback messaging.ErrorCallbackFunction)
    {{- end}}
{{- end}}
}

// ProducerInterface Interface for all events to be produced by application
type ProducerInterface interface {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{camel $channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}, header ...messaging.KafkaHeader) error
    {{- end}}
{{- end}}
}

// DefaultConsumer implements ConsumerInterface and consumes events with go kafka mosaic style flavor
type DefaultConsumer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic messaging.KafkaTopic
    {{- end}}
{{- end}}
}

// DefaultProducer implements ProducerInterface and produces events with go kafka mosaic style flavor
type DefaultProducer struct {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic messaging.KafkaTopic
    {{- end}}
{{- end}}
}

// NewDefaultConsumer wires all needed dependencies to create a DefaultConsumer
func NewDefaultConsumer(manager messaging.KafkaManager, config KafkaTopicConfig) (*DefaultConsumer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateTopic({{ lower $channelName | camel}}TopicName, config.TopicGroup, config.NumPartitions, config.ReplicationFactor)
	if err != nil {
		return nil, err
	}
    {{- end}}
{{- end}}
	return &DefaultConsumer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

// NewDefaultProducer wires all needed dependencies to create a DefaultProducer
func NewDefaultProducer(manager messaging.KafkaManager, config KafkaTopicConfig) (*DefaultProducer, error) {
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
	{{ lower $channelName | camel}}Topic, err := manager.CreateTopic({{ lower $channelName | camel}}TopicName, config.TopicGroup, config.NumPartitions, config.ReplicationFactor)
	if err != nil {
		return nil, err
	}
    {{- end}}
{{- end}}
	return &DefaultProducer{
{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
		{{ lower $channelName | camel}}Topic: {{ lower $channelName | camel}}Topic,
    {{- end}}
{{- end}}
	}, nil
}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.publish}}
//{{camel $channel.publish.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to consume the {{$channel.publish.message.name}} Event.
func (d DefaultConsumer)  {{camel $channel.publish.operationId}} (callback messaging.CallbackFunction, errorCallback messaging.ErrorCallbackFunction) {
	d.{{ lower $channelName | camel}}Topic.Consume({{$channel.publish.message.name}}{}, callback, errorCallback)
}
    {{- end}}
{{ end}}

{{- range $channelName, $channel := .channels }}
    {{- if $channel.subscribe}}
//{{camel $channel.subscribe.operationId}} is the go kafka mosaic style flavored implementation of the ConsumerInterface registered on DefaultConsumer
// to produce the {{$channel.subscribe.message.name}} Event.
func (d DefaultProducer) {{camel $channel.subscribe.operationId}}(ctx context.Context, event {{$channel.subscribe.message.name}}, header ...messaging.KafkaHeader) error {
	err := d.{{ lower $channelName | camel}}Topic.Produce(ctx, event, header...)
	if err != nil {
		return err
	}
	return nil
}
    {{- end}}
{{- end}}